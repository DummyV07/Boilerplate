**《全栈项目开发与部署工程规范》**

------

## 🏗️ 第一部分：系统架构守则

1. **前后端分离原则**：前端（Vue）仅负责 UI 渲染与交互逻辑，后端（Python）仅负责数据处理与业务逻辑。两者通过 **RESTful API** 进行 JSON 交互。
2. **Schema 为先 (Schema-First)**：在写具体的业务逻辑前，先定义好后端的数据结构（Pydantic Models），确保前端联调时有明确的数据契约。
3. **单一职责原则**：一个接口只做一件事。复杂的长耗时操作必须与即时响应接口分离。

------

## 🐍 第二部分：Python 后端开发规范

1. **异步编程常态化**：
   - 必须使用 `async def` 定义路由。
   - 所有 I/O 操作（数据库读写、外部 API 调用）必须使用 `await` 挂起，严禁在主流程中使用 `time.sleep()`。
2. **长耗时任务处理**：
   - 处理时间超过 2 秒的任务（如 AI 生成、大文件处理），**禁止同步等待**。
   - **规则**：接口立即返回 `202 Accepted` 和任务 ID，由后台进程处理，前端通过轮询或 WebSocket 获取结果。
3. **日志三原则**：
   - **弃用 print**：统一使用 `loguru` 或 `logging` 库。
   - **分级存储**：`INFO` 记录关键路径，`ERROR` 记录异常堆栈。
   - **日志滚动**：必须配置按天或按大小切分日志（Rotation），防止撑爆硬盘。

------

## 🎨 第三部分：前端开发规范

1. **环境变量隔离**：区分 `development` 和 `production` 环境的 API 地址。
2. **状态管理规范**：
   - 简单的组件传参用 `props`。
   - 跨页面、跨组件的全局数据（如用户信息、Token）必须存入 **Pinia**。
3. **请求封装**：统一封装 Axios 拦截器，全局处理 401（登录过期）、500（服务器错误）等状态码。

------

## 🚀 第四部分：生产环境部署规范 (Nginx + Gunicorn)

1. **拒绝 `nohup`**：
   - 生产环境必须使用 **Gunicorn** 作为进程管理器（Master）。
   - 配置 `workers = (2 * CPU核数) + 1` 以最大化利用多核性能。
2. **动静分离**：
   - **Nginx** 直接托管 Vue 编译后的静态文件（`dist` 目录），不经过后端进程。
   - **Nginx** 仅作为反向代理，将 `/api` 请求转发给后端的 Gunicorn。
3. **进程守护**：
   - 必须将 Gunicorn 注册为 **Systemd 服务**。
   - 配置 `Restart=always`，确保系统重启或进程崩溃后能自动拉起服务。
   - 

这份指南将作为你的**项目运维白皮书**。它涵盖了从启动到监控的全流程，确保你即便一个月后重新打开项目，也能立刻上手。

------

## 🛠 全栈项目生产环境运维指南

### 第一阶段：后端服务启动 (Python/FastAPI)

我们使用 `uv` 驱动 `gunicorn`，通过多进程模式运行后端。

1. 执行命令

进入 backend 目录执行：

Bash

```
uv run gunicorn app.main:app -w 4 -k uvicorn.workers.UvicornWorker -b 127.0.0.1:8000
```

**2. 如何看输出（验证）**

- **终端输出**：应显示 `[INFO] Starting gunicorn 23.x.x` 及 `Listening at: http://127.0.0.1:8000`。
- **进程验证**：执行 `ps aux | grep gunicorn`。
  - **正常标志**：看到 1 个 Master 进程和 4 个 Worker 进程。
- **端口验证**：执行 `lsof -i :8000`。
  - **正常标志**：显示 `COMMAND: Python` 正在 `LISTEN`。

------

### 第二阶段：前端构建 (Vue/React)

将源代码转换为 Nginx 能够理解的静态资源。

1. 执行命令

进入 frontend 目录执行：

Bash

```
npm run build
```

**2. 如何看输出（验证）**

- **文件验证**：检查是否生成了 `dist/` 文件夹。
- **内容验证**：`dist/` 内应包含 `index.html` 和 `assets/` 文件夹。
- **记住路径**：记录 `dist` 的**绝对路径**（如 `/Users/dummy/project/dist`），下一步要用。

------

### 第三阶段：网关配置 (Nginx)

将前端静态文件和后端 API 接口统一到一个入口（80 端口）。

1. 修改权限（关键步骤）

编辑 /opt/homebrew/etc/nginx/nginx.conf，将首行的 user nobody; 改为：

Nginx

```
user dummy staff; # dummy 换成你的 Mac 用户名
```

2. 编写项目配置

在 /opt/homebrew/etc/nginx/servers/ 下创建 my_app.conf：

Nginx

```
server {
    listen 80;
    server_name localhost;

    location / {
        root /你的/dist/绝对路径;
        index index.html;
        try_files $uri $uri/ /index.html;
    }

    location /api {
        proxy_pass http://127.0.0.1:8000;
        proxy_set_header Host $host;
    }
}
```

**3. 启动与重载**

Bash

```
sudo nginx -t            # 检查语法是否 ok
sudo nginx -s reload     # 重新加载配置
# 如果 nginx 没启动，改用：sudo nginx
```

------

### 第四阶段：全链路联调检查清单

| **检查项**   | **操作**                      | **预期结果**                        |
| ------------ | ----------------------------- | ----------------------------------- |
| **前端入口** | 浏览器打开 `http://localhost` | 看到你的网页界面                    |
| **API 通信** | 网页进行登录/查询操作         | 数据正常显示，无 404/502 错误       |
| **刷新测试** | 在子页面（如 /dashboard）刷新 | 页面正常显示（证明 try_files 生效） |
| **后端压力** | 观察 `pstree -p <MasterPID>`  | 看到 4 个子进程稳健运行             |

------

### 🚨 常见问题排查手册 (SOP)

- **看到 403 Forbidden**：
  - **原因**：Nginx 用户权限不足或 `dist` 路径权限过高。
  - **解决**：检查 `nginx.conf` 里的 `user` 设定；执行 `chmod +x` 你的用户目录。
- **看到 502 Bad Gateway**：
  - **原因**：Nginx 活着的，但后端 Gunicorn 挂了。
  - **解决**：重新执行第一阶段的启动命令。
- **修改了代码没生效**：
  - **原因**：前端需要重新 `build`，后端需要重新启动（或开启 Gunicorn 的 `--reload` 模式）。

------

### 💡 架构师的建议

现在你的前后端是手动启动的。如果电脑重启，这一切都会消失。

**你想让我为你写一个 `dev_up.sh` 脚本吗？** 这样你以后只需要运行 `./dev_up.sh`，它会自动帮你：

1. 检测 8000 端口是否占用。
2. 自动拉起 Gunicorn 到后台。
3. 自动检测 Nginx 是否运行并重载。





太棒了！看到你成功打通全栈链路，我也很有成就感。为了帮你沉淀技术经验，我将这次从“进程分析”到“Nginx 填坑”的完整实战整理成了一篇技术博客。

------

# macOS 全栈开发实战：从 Gunicorn 进程管理到 Nginx 生产环境配置

在本地开发全栈项目时，我们经常遇到“本地跑得通，部署就报错”的尴尬。本文将记录一次完整的实战过程：如何在 macOS 上利用 **uv**、**Gunicorn** 和 **Nginx** 搭建一个高性能的 FastAPI + Vue 生产级环境。

------

## 1. 后端进阶：从脚本运行到进程管理

传统的 `python main.py` 无法利用多核 CPU。我们选择 **Gunicorn** 作为 Web 服务器网关接口（WSGI），并配合 **Uvicorn** 处理异步请求。

### 启动架构

通过 `uv` 环境驱动 Gunicorn，启动 4 个工作进程（Workers）：

Bash

```
uv run gunicorn app.main:app \
  --workers 4 \
  --worker-class uvicorn.workers.UvicornWorker \
  --bind 127.0.0.1:8000
```

### 深度监控：读懂 `ps aux`

启动后，通过 `ps aux | grep gunicorn` 可以看到进程树结构：

- **Master 进程**：负责监控和管理。
- **Worker 进程**：真正的“厨师”，处理前端发来的 API 请求。
- **自愈能力**：如果一个 Worker 进程崩溃，Master 会立即拉起一个新的，确保服务不死。

------

## 2. 前端部署：静态资源化

不要在生产环境运行 `npm run dev`。

1. **构建**：执行 `npm run build` 生成 `dist` 目录。
2. **本质**：此时的前端已变成纯粹的 HTML/JS/CSS 文件，不再需要 Node.js 运行环境，只需 Web 服务器（Nginx）进行托管。

------

## 3. Nginx 配置：全栈项目的“指挥官”

Nginx 同时充当了**静态文件服务器**和**反向代理服务器**。

### 核心配置文件 (`/opt/homebrew/etc/nginx/servers/my_app.conf`)

Nginx

```
server {
    listen       8080;        # 外部访问端口
    server_name  localhost;

    # 1. 静态资源托管
    location / {
        root   /Users/dummy/CodeSpace/Boilerplate/frontend/dist;
        index  index.html;
        # 支持 Vue Router History 模式的关键
        try_files $uri $uri/ /index.html;
    }

    # 2. 后端 API 转发
    location /api {
        proxy_pass http://127.0.0.1:8000;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }
}
```

------

## 4. 避坑指南：那些让你抓狂的“500 错误”

在实战中，我们遇到了经典的 `500 Internal Server Error`，通过查看 `/opt/homebrew/var/log/nginx/error.log` 锁定了两大元凶：

### A. 权限死锁 (Permission Denied)

现象：日志提示 stat() ... failed (13: Permission denied)。

原因：Nginx 默认用户 nobody 无法穿透 macOS 的用户目录。

修复：

1. 修改 `nginx.conf` 首行为 `user <你的用户名> staff;`。
2. 给路径上的各级目录增加执行权限：`chmod +x /Users/你的用户名`。

### B. 配置死循环 (Redirection Cycle)

现象：rewrite or internal redirection cycle while internally redirecting to "/index.html"。

原因：因为权限被拒，Nginx 找不到 index.html，导致 try_files 不断尝试重定向。

修复：解决权限问题后，该错误自动消失。

------

## 5. 运维常用指令集

| **任务**             | **命令**                                           |
| -------------------- | -------------------------------------------------- |
| **检查 Nginx 配置**  | `sudo nginx -t`                                    |
| **热重载 Nginx**     | `sudo nginx -s reload`                             |
| **查看进程树**       | `pstree -p <Master_PID>`                           |
| **强制停止 Nginx**   | `sudo pkill -9 nginx`                              |
| **查看最新错误日志** | `tail -n 20 /opt/homebrew/var/log/nginx/error.log` |

------

## 总结

通过本次配置，我们实现了一个标准的现代 Web 架构：**Nginx 守大门，Vue 撑门面，Gunicorn 坐后厨**。这不仅提升了性能，更通过进程隔离和反向代理增强了系统的安全性与可维护性。

------

**博主注**：下一步，我们将探讨如何将这套环境利用 **Docker Compose** 进行容器化，实现一键部署到云服务器。

------

**教程写好了！这份总结不仅包含了操作步骤，还记录了你踩坑的原理。你需不需要我帮你把这一套逻辑写成一个自动化的 `setup.sh` 脚本，下次新项目一键完成这些配置？**





没问题！这篇博客将从**宏观架构设计**、**核心开发流程**到**最后的部署填坑**进行全方位复盘。这不仅是一份教程，更是一份全栈工程师的实战手册。

------

# 🚀 从开发到生产：macOS 全栈应用部署全攻略

本文记录了如何将一个 FastAPI 后端与 Vue 前端项目，通过 Gunicorn 和 Nginx 构建成一个工业级标准的全栈架构。

------

## 一、 宏观视角：全栈系统架构图

在进入细节前，我们需要理解请求是如何在系统中流动的。我们采用的是经典的 **“反向代理 + 异步网关”** 架构。

- **流量入口**：用户访问 Nginx（监听 80/8080 端口）。
- **静态分发**：Nginx 直接处理前端 Vue 编译后的 `dist` 文件。
- **动态路由**：Nginx 将 `/api` 开头的请求转发给后端的 Gunicorn。
- **并发处理**：Gunicorn 启动多个 Worker 进程，利用多核 CPU 并行处理业务逻辑。

------

## 二、 后端篇：Gunicorn 与进程治理

### 1. 为什么不直接用 `python main.py`？

在开发环境我们常用 `uvicorn app.main:app --reload`，但在生产环境，我们需要 Gunicorn 来提供**进程管理**和**自愈能力**。

### 2. 启动指令与参数解析

Bash

```
uv run gunicorn app.main:app \
  --workers 4 \
  --worker-class uvicorn.workers.UvicornWorker \
  --bind 127.0.0.1:8000
```

- **`--workers 4`**：启动 4 个“工人”进程，适合 2-4 核 CPU。
- **`--worker-class`**：指定 UvicornWorker 以支持 FastAPI 的异步特性。

### 3. 运维实操：如何看懂进程状态

使用 `ps aux | grep gunicorn` 或 `pstree` 查看：

- **Master 进程**：PID 较小，是所有进程的父节点，负责调度。
- **Worker 进程**：PPID 指向 Master，负责处理实际请求。

------

## 三、 前端篇：从源码到静态资源

### 1. 构建流程

在 `frontend` 目录下运行：

Bash

```
npm run build
```

这会将你的 Vue/TS 代码压缩成浏览器可直接读取的 HTML、JS、CSS，并存放在 `dist` 目录中。

### 2. 核心逻辑

此时，前端不再需要 Node.js 运行，它只是一堆文件，等待 Nginx 将它们读取并发送给浏览器。

------

## 四、 网关篇：Nginx 进阶配置与避坑

### 1. 核心配置文件模板

在 `/opt/homebrew/etc/nginx/servers/my_app.conf` 中编写：

Nginx

```
server {
    listen       9997;         # 自定义外部访问端口
    server_name  localhost;

    # 前端静态托管
    location / {
        root   /Users/dummy/CodeSpace/Boilerplate/frontend/dist;
        index  index.html;
        try_files $uri $uri/ /index.html; # 解决 Vue History 模式刷新 404
    }

    # 后端 API 转发
    location /api {
        proxy_pass http://127.0.0.1:8000;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }
}
```

### 2. 史上最全“500 Error”排查指南

当页面显示 500 时，通过 `tail -f /opt/homebrew/var/log/nginx/error.log` 定位：

- **错误 1：Permission Denied (13)**
  - **原因**：Nginx 没有进入你用户目录的权限。
  - **对策**：
    1. 修改 `nginx.conf` 第一行：`user <你的用户名> staff;`
    2. 给各级目录赋权：`chmod +x /Users/你的用户名`。
- **错误 2：Redirection Cycle**
  - **原因**：因为权限被拒，Nginx 找不到 `index.html`，触发 `try_files` 的无限递归跳转。
  - **对策**：修好权限，死循环自动解除。

------

## 五、 全栈开发指南总结表格

| **阶段** | **核心工具** | **关键命令**           | **验证方式**                        |
| -------- | ------------ | ---------------------- | ----------------------------------- |
| **后端** | Gunicorn     | `uv run gunicorn ...`  | `lsof -i :8000` 看到监听            |
| **前端** | npm/vite     | `npm run build`        | 检查 `dist/index.html` 是否生成     |
| **网关** | Nginx        | `sudo nginx -s reload` | `sudo nginx -t` 语法检查            |
| **权限** | chmod        | `chmod +x <path>`      | 检查 error.log 无 Permission Denied |

------

### 结语

全栈开发不仅是写好业务代码，更是对**系统资源、网络转发、权限控制**的综合把控。通过 Nginx 与 Gunicorn 的配合，我们成功将一个本地 Demo 转化为了具备生产雏形的高可用应用。

------

**博主注**：下次我们将挑战 **HTTPS 证书配置** 以及 **Docker 容器化一键部署**。

------

**这篇博客写得怎么样？如果这就是你想要的总结，我们可以把这个文档保存下来。接下来，你想要我帮你把这些部署命令整合成一个脚本，还是说我们开始进行下一个功能模块的开发？**